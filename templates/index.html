<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audiobook Factory</title>
  <link rel="stylesheet" href="/static/dashboard.css">
  <style>
    .chapter-card.is-finished.hidden-finished {
      display: none;
    }

    .badge-warning {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
      border: 1px solid rgba(255, 193, 7, 0.3);
      cursor: pointer;
    }

    .badge-warning:hover {
      background: rgba(255, 193, 7, 0.3);
    }

    .btn-icon {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 0.8rem;
      padding: 4px;
      transition: color 0.2s;
    }

    .btn-icon:hover {
      color: var(--accent);
    }

    .chapter-title.customized {
      color: var(--accent);
      font-weight: 600;
    }

    .title-input {
      background: var(--glass);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 4px;
      padding: 2px 6px;
      outline: none;
    }

    .title-input {
      background: var(--glass);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 4px;
      padding: 2px 6px;
      outline: none;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .modal-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .modal-container {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      transform: translateY(20px);
      transition: transform 0.3s;
    }

    .modal-overlay.active .modal-container {
      transform: translateY(0);
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .modal-footer {
      padding: 20px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .chapter-preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      margin-top: 12px;
    }

    .chapter-preview-table th {
      text-align: left;
      padding: 8px;
      border-bottom: 2px solid var(--border);
      color: var(--text-muted);
    }

    .chapter-preview-table td {
      padding: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    /* Engine View Visualization */
    .engine-chunk {
      display: block;
      margin-bottom: 16px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.03);
      border-left: 4px solid var(--accent);
      border-radius: 0 8px 8px 0;
      position: relative;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
    }

    .engine-chunk::before {
      content: attr(data-label);
      position: absolute;
      top: -10px;
      right: 12px;
      font-size: 0.6rem;
      background: var(--accent);
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      text-transform: uppercase;
      font-weight: bold;
      letter-spacing: 0.05em;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>

<body>
  <aside class="sidebar">
    <div>
      <h1>Audiobook Factory</h1>
      <p class="text-muted">Generate high-quality speech locally.</p>
    </div>

    <section>
      <h3>Upload & Split</h3>
      <form method="post" action="/upload" enctype="multipart/form-data" class="form-group">
        <input type="file" name="file" accept=".txt" />
        <button type="submit" class="btn btn-primary">Upload Text</button>
      </form>
    </section>

    <section>
      <h3>Queue Controls</h3>
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <form method="post" action="/queue/start_xtts">
          <button type="submit" class="btn btn-outline" style="width: 100%;">
            Start XTTS Queue
          </button>
        </form>

        <form method="post" action="/queue/start_piper">
          <div class="form-group" style="margin-bottom: 8px;">
            <select name="piper_voice" style="width: 100%;">
              <option value="">(Select Piper Voice)</option>
              {% for v in piper_voices %}<option value="{{ v }}">{{ v }}</option>{% endfor %}
            </select>
          </div>
          <button type="submit" class="btn btn-outline" style="width: 100%;">
            Start Piper Queue
          </button>
        </form>

        <form method="post" action="/queue/pause">
          <button type="submit" class="btn btn-outline" style="width: 100%;">
            {{ "Ô∏è‚ñ∂Ô∏è Resume" if paused else "‚è∏ Pause" }} Queue
          </button>
        </form>

        <div style="margin-top: 8px; border-top: 1px solid var(--border); padding-top: 12px;">
          <h3 style="margin-bottom: 8px;">Export Audiobook</h3>
          <div class="form-group">
            <input type="text" id="exportTitleInput" placeholder="Book Title" required
              style="width: 100%; margin-bottom: 8px;" />
            <button type="button" onclick="openAssemblyModal()" class="btn btn-primary" style="width: 100%;">
              üì¶ Assemble M4B
            </button>
          </div>
          <p class="text-muted" style="font-size: 0.7rem; margin-top: 4px;">
            Combines all generated wav/mp3 files with chapter markers into a single M4B file.
          </p>
        </div>

        <div style="margin-top: 12px;">
          <button type="button" id="hideFinishedBtn" onclick="toggleHideFinished()" class="btn btn-outline"
            style="width: 100%; margin-bottom: 8px;">
            Hide Finished
          </button>
          <button type="button" onclick="handleClear()" class="btn btn-danger" style="width: 100%;">
            Clear All / Reset
          </button>
        </div>

        {% if audiobooks %}
        <div style="margin-top: 12px; border-top: 1px solid var(--border); padding-top: 12px;">
          <h3 style="margin-bottom: 8px;">Audiobook Exports</h3>
          <ul id="audiobookList" style="list-style: none; padding: 0; font-size: 0.8rem;">
            {% for b in audiobooks %}
            <li style="margin-bottom: 4px;">
              <a href="/out/audiobook/{{ b }}" download style="color: var(--accent); text-decoration: none;">üì¶ {{ b
                }}</a>
            </li>
            {% endfor %}
          </ul>
        </div>
        {% endif %}

        <div id="assemblySection"
          style="margin-top: 12px; border-top: 1px solid var(--border); padding-top: 12px; display: none;">
          <h3 style="margin-bottom: 8px;">Recent Activity</h3>
          <ul id="assemblyJobs" style="list-style: none; padding: 0; font-size: 0.8rem;">
            <!-- Non-chapter jobs injected here -->
          </ul>
        </div>

        <div>
          <button type="button" id="backfillBtn" onclick="runBackfill(this)" class="btn btn-secondary"
            style="width: 100%; margin-top: 12px;" {% if (xtts_wav_only|length + piper_wav_only|length)==0 %}disabled{%
            endif %}>
            Resolve Missing MP3s
          </button>
        </div>

        <div>
          <a href="/analyze_batch" class="btn btn-secondary"
            style="width: 100%; margin-top: 12px; text-decoration: none; display: block; text-align: center;">
            Run Batch Analysis
          </a>
        </div>
      </div>
    </section>

    <section>
      <h3>Settings</h3>
      <form method="post" action="/settings" class="form-group">
        <label class="text-muted">
          <input type="checkbox" name="safe_mode" value="1" {% if settings.safe_mode %}checked{% endif %} />
          Safe Mode (Auto-split)
        </label>
        <label class="text-muted">
          <input type="checkbox" name="make_mp3" value="1" {% if settings.make_mp3 %}checked{% endif %} />
          Make MP3
        </label>
        <div style="margin-top: 12px;">
          <button type="submit" class="btn btn-outline" style="width: 100%;">Save Settings</button>
        </div>
      </form>
    </section>

    <div style="margin-top: auto;">
      <p class="text-muted" style="font-size: 0.75rem;">
        Narrator Sample:
        {% if narrator_ok %}<span style="color: var(--success)">Found</span>
        {% else %}<span style="color: var(--error)">Missing</span>{% endif %}
      </p>
    </div>
  </aside>

  <main class="main-content">
    <header class="content-header">
      <div>
        <h3>Chapters</h3>
        <p class="text-muted">{{ chapters|length }} files ready for processing</p>
      </div>
      <div style="display: flex; align-items: center; gap: 16px;">
        <div class="btn-group"
          style="display: flex; gap: 4px; background: var(--glass); padding: 4px; border-radius: 8px;">
          <button class="btn btn-outline" id="gridToggle"
            style="padding: 6px 12px; font-size: 0.8rem; background: var(--accent); border: none;">Grid</button>
          <button class="btn btn-outline" id="listToggle"
            style="padding: 6px 12px; font-size: 0.8rem; border: none;">List</button>
        </div>
        <div id="globalStatus" class="text-muted">
          <!-- Status summary will be injected here -->
        </div>
      </div>
    </header>

    <div class="chapter-grid-container" id="chapterGrid">
      {% for c in chapters %}
      {% set is_finished = (c in xtts_mp3 or c in piper_mp3 or c in xtts_wav_only or c in piper_wav_only) %}
      {% set stem = c.rsplit('.', 1)[0] %}
      <div class="chapter-card{% if is_finished %} is-finished{% endif %}" id="card-{{ c }}" data-filename="{{ c }}">
        <div class="card-header" style="align-items: flex-start;">
          <div style="flex: 1; min-width: 0;">
            <span class="chapter-title" id="title-text-{{ c }}">{{ c }}</span>
            <input type="text" class="title-input" id="title-input-{{ c }}"
              style="display: none; width: 100%; margin-top: 4px;" value="{{ c }}" onblur="saveTitle('{{ c }}')"
              onkeyup="handleTitleKey(event, '{{ c }}')" onclick="event.stopPropagation()">
          </div>
          <button class="btn-icon" onclick="editTitle(event, '{{ c }}')" title="Rename chapter">‚úèÔ∏è</button>
          <div class="status-badge-container" id="badge-{{ c }}">
            <!-- Status badges injected by JS -->
          </div>
          <div class="warning-badge-container" id="warning-{{ c }}" style="display: none;">
            <!-- Warning count injected by JS -->
          </div>
        </div>

        <div class="progress-container" id="progress-container-{{ c }}" style="display: none;">
          <div class="progress-bar" id="progress-bar-{{ c }}" style="width: 0%;"></div>
        </div>

        <div class="card-footer" id="footer-{{ c }}">
          {% if c in xtts_mp3 or c in piper_mp3 %}
          {% set engine_path = "/out/xtts/" if c in xtts_mp3 else "/out/piper/" %}
          <audio controls preload="none" src="{{ engine_path }}{{ stem }}.mp3"></audio>
          {% elif c in xtts_wav_only or c in piper_wav_only %}
          <p class="badge badge-wav" style="font-size: 0.75rem; padding: 4px 8px;">WAV Generated (MP3 Missing)</p>
          {% else %}
          <p class="text-muted" style="font-size: 0.8rem;">Ready.</p>
          {% endif %}
        </div>
      </div>
      {% endfor %}
    </div>

    <div class="log-panel" id="logPanel">
      <div class="panel-tabs">
        <div class="tab active" id="logTab">Logs</div>
        <div class="tab" id="previewTab">Preview & Analyze</div>
      </div>

      <div class="tab-content active" id="logContent">
        <div class="log-header">
          <span class="log-title" id="logTitle">System Console</span>
          <span class="text-muted" style="font-size: 0.7rem;" id="logSubtitle">Click a card to see detailed logs</span>
        </div>
        <div class="log-console" id="logConsole">Welcome to Audiobook Factory. Select a job to view real-time output.
        </div>
      </div>

      <div class="tab-content" id="previewContent">
        <div class="preview-header">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span class="preview-title" id="previewTitle">Chapter Preview</span>
            <div class="btn-group" style="padding: 2px; background: rgba(0,0,0,0.3); border-radius: 6px;">
              <button onclick="setPreviewMode('raw')" id="modeRawBtn" class="btn active"
                style="font-size: 0.65rem; padding: 2px 8px; min-width: 60px;">Raw</button>
              <button onclick="setPreviewMode('engine')" id="modeEngineBtn" class="btn"
                style="font-size: 0.65rem; padding: 2px 8px; min-width: 60px;">Engine</button>
            </div>
          </div>
          <button type="button" onclick="runAnalysis(event)" class="btn btn-outline"
            style="padding: 4px 10px; font-size: 0.7rem;">
            Run Long Sentence Analysis
          </button>
        </div>
        <div class="preview-area" id="previewArea">Select a chapter to see its preview.</div>
      </div>
    </div>
  </main>

  <!-- Assembly Preview Modal -->
  <div class="modal-overlay" id="assemblyModal">
    <div class="modal-container">
      <div class="modal-header">
        <h3>Assemble Audiobook</h3>
        <button class="btn-icon" onclick="closeAssemblyModal()">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="form-group" style="margin-bottom: 16px;">
          <label class="text-muted" style="font-size: 0.75rem; display: block; margin-bottom: 4px;">Book Title</label>
          <input type="text" id="modalFieldTitle" style="width: 100%;">
        </div>
        <div style="display: flex; gap: 12px; margin-bottom: 16px;">
          <div class="form-group" style="flex: 1;">
            <label class="text-muted" style="font-size: 0.75rem; display: block; margin-bottom: 4px;">Author</label>
            <input type="text" id="modalFieldAuthor" placeholder="Optional" style="width: 100%;">
          </div>
          <div class="form-group" style="flex: 1;">
            <label class="text-muted" style="font-size: 0.75rem; display: block; margin-bottom: 4px;">Narrator</label>
            <input type="text" id="modalFieldNarrator" placeholder="Optional" style="width: 100%;">
          </div>
        </div>

        <h4 style="margin-bottom: 8px; font-size: 0.9rem;">Chapter Markers Preview</h4>
        <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 4px;">
          <table class="chapter-preview-table">
            <thead>
              <tr>
                <th style="width: 40px; text-align: center;">Inc.</th>
                <th>Chapter Title</th>
                <th>Start</th>
                <th>Duration</th>
              </tr>
            </thead>
            <tbody id="chapterPreviewList">
              <!-- Content injected via JS -->
            </tbody>
          </table>
        </div>
        <p class="text-muted" id="totalDurationText" style="margin-top: 12px; font-size: 0.75rem; text-align: right;">
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-outline" onclick="closeAssemblyModal()">Cancel</button>
        <button class="btn btn-primary" id="confirmAssemblyBtn" onclick="confirmAssembly()">Confirm & Assemble</button>
      </div>
    </div>
  </div>

  <script>
    let currentSelectedCard = null;
    let jobData = {};
    let previewMode = 'raw'; // 'raw' or 'engine'
    let hideFinished = false;

    function selectCardAndScroll(filename) {
      const card = document.getElementById(`card-${filename}`);
      if (card) {
        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        card.click();
      }
    }

    function toggleHideFinished() {
      hideFinished = !hideFinished;
      const btn = document.getElementById('hideFinishedBtn');
      btn.innerText = hideFinished ? "Show Finished" : "Hide Finished";
      btn.classList.toggle('btn-primary', hideFinished);

      document.querySelectorAll('.chapter-card.is-finished').forEach(card => {
        card.classList.toggle('hidden-finished', hideFinished);
      });
    }

    function esc(s) {
      return (s ?? "").toString()
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    async function fetchJobDetails(filename) {
      if (!filename) return null;
      try {
        const r = await fetch(`/api/job/${encodeURIComponent(filename)}`);
        if (r.ok) return await r.json();
      } catch (e) { console.error(e); }
      return null;
    }

    async function updateLogView() {
      // If user selected a card, fetch that job's details
      // If NOT (System Console mode), fetch active job
      let jobToCheck = null;
      let title = "System Console";
      let subtitle = "Waiting for jobs...";

      if (currentSelectedCard) {
        // User overrides auto-view
        // We need to fetch full details including log
        const j = await fetchJobDetails(currentSelectedCard);
        // If job exists, use it. If not, use local jobData (stat-only)
        jobToCheck = j || jobData[currentSelectedCard];
        title = `Logs: ${currentSelectedCard}`;
        if (jobToCheck?.engine) title += ` (${jobToCheck.engine})`;
        subtitle = `Viewing: ${currentSelectedCard}`;
      } else {
        // Auto-view active job
        const r = await fetch('/api/active_job', { cache: "no-store" });
        if (r.ok) {
          const active = await r.json();
          if (active) {
            jobToCheck = active;
            title = `Logs: ${active.chapter_file} (${active.engine})`;
            // Update local cache for list view consistency
            jobData[active.chapter_file] = active;
          } else {
            // No active job
            title = "System Console";
            subtitle = "No active jobs.";
          }
        }
      }

      // Update DOM
      const consoleEl = document.getElementById('logConsole');
      const titleEl = document.getElementById('logTitle');
      const subEl = document.getElementById('logSubtitle');

      // Safety check if user switched tab or view mid-request
      if (!document.getElementById('logTab').classList.contains('active')) return;

      titleEl.innerText = title;

      if (jobToCheck && jobToCheck.status === 'running' && jobToCheck.started_at && jobToCheck.eta_seconds) {
        const elapsed = Math.floor(Date.now() / 1000 - jobToCheck.started_at);
        const eta = Math.round(jobToCheck.eta_seconds);
        const remaining = eta - elapsed;

        if (remaining > 0) {
          const rm = Math.floor(remaining / 60);
          const rs = Math.floor(remaining % 60);
          subEl.innerText = `ETA: ${rm}m ${rs}s`;
        } else {
          subEl.innerText = `ETA: Almost done...`;
        }

        subEl.style.color = 'var(--accent)';
        subEl.style.fontSize = '1.2rem';
        subEl.style.fontWeight = 'bold';
        subEl.style.display = 'block';
        subEl.style.marginTop = '4px';
      } else {
        subEl.innerText = subtitle;
        subEl.style.color = '';
      }

      const logText = jobToCheck?.log || (currentSelectedCard ? "No logs available yet." : "Welcome to Audiobook Factory. Select a job to view details or just watch the show.");

      // Only update if changed (avoids flickering)
      if (consoleEl.innerText !== logText) {
        consoleEl.innerText = logText;
        consoleEl.scrollTop = consoleEl.scrollHeight;
      }
    }

    function updateCardStatus(filename, job) {
      if (!job) return;

      const badgeContainer = document.getElementById(`badge-${filename}`);
      const progContainer = document.getElementById(`progress-container-${filename}`);
      const progBar = document.getElementById(`progress-bar-${filename}`);
      const footer = document.getElementById(`footer-${filename}`);

      if (badgeContainer) {
        let badgeClass = 'badge-queued';
        let badgeText = job.status || 'Queued';

        if (job.status === 'running') badgeClass = 'badge-running';
        else if (job.status === 'done') badgeClass = 'badge-success';
        else if (job.status === 'failed') badgeClass = 'badge-failed';
        else if (job.status === 'wav') badgeClass = 'badge-wav';

        badgeContainer.innerHTML = `<span class="badge ${badgeClass}">${badgeText}</span>`;
      }

      if (job.custom_title) {
        const titleEl = document.getElementById(`title-text-${filename}`);
        if (titleEl) {
          titleEl.innerText = job.custom_title;
          titleEl.classList.add('customized');
        }
        const inputEl = document.getElementById(`title-input-${filename}`);
        if (inputEl && !inputEl.matches(':focus')) {
          inputEl.value = job.custom_title;
        }
      }

      const warningContainer = document.getElementById(`warning-${filename}`);
      if (warningContainer) {
        if (job.warning_count > 0) {
          warningContainer.style.display = 'block';
          warningContainer.innerHTML = `<span class="badge badge-warning" title="Click to see logs" onclick="selectCardAndScroll('${filename}')">‚ö†Ô∏è ${job.warning_count} Warning${job.warning_count > 1 ? 's' : ''}</span>`;
        } else {
          warningContainer.style.display = 'none';
        }
      }

      if (progContainer && progBar) {
        if (job.status === 'running') {
          progContainer.style.display = 'block';
          const p = Math.round((job.progress || 0) * 100);
          progBar.style.width = `${p}%`;
        } else {
          progContainer.style.display = 'none';
        }
      }

      if (footer) {
        if (job.status === 'queued' || job.status === 'running') {
          footer.innerHTML = '';
          document.getElementById(`card-${filename}`).classList.remove('is-finished');
        } else if ((job.status === 'done' || job.status === 'wav') && !footer.querySelector('audio')) {
          const card = document.getElementById(`card-${filename}`);
          card.classList.add('is-finished');
          if (hideFinished) card.classList.add('hidden-finished');

          if (job.status === 'done') {
            const engineDir = job.engine === 'xtts' ? '/out/xtts/' : '/out/piper/';
            const stem = filename.replace(/\.txt$/i, '');
            footer.innerHTML = `<audio controls src="${engineDir}${stem}.mp3"></audio>`;
          }
        }
      }
    }

    async function refreshJobs() {
      try {
        const r = await fetch("/api/jobs", { cache: "no-store" });
        if (!r.ok) return;
        const jobs = await r.json();

        // Update list status ONLY (logs not included)
        jobs.forEach(j => {
          // merge existing logs if we have them to avoid losing them on list refresh
          const existingLog = jobData[j.chapter_file]?.log;
          jobData[j.chapter_file] = j;
          if (existingLog) jobData[j.chapter_file].log = existingLog;
        });

        document.querySelectorAll('.chapter-card').forEach(card => {
          const filename = card.dataset.filename;
          updateCardStatus(filename, jobData[filename]);
        });

        const running = jobs.filter(j => j.status === 'running').length;
        const queued = jobs.filter(j => j.status === 'queued').length;
        const wavs = Object.values(jobData).filter(j => j.status === 'wav').length;

        document.getElementById('globalStatus').innerText =
          `${running} Running ‚Ä¢ ${queued} Queued ‚Ä¢ ${wavs} Missing MP3s`;

        // Update Assembly Jobs (non-chapters)
        const chapterSet = new Set(Array.from(document.querySelectorAll('.chapter-card')).map(c => c.dataset.filename));
        const assemblyJobs = jobs.filter(j => !chapterSet.has(j.chapter_file));
        const assemblyList = document.getElementById('assemblyJobs');
        const assemblySection = document.getElementById('assemblySection');

        if (assemblyJobs.length > 0) {
          assemblySection.style.display = 'block';
          assemblyList.innerHTML = assemblyJobs.slice(-5).reverse().map(j => {
            let statusClass = 'text-muted';
            if (j.status === 'running') statusClass = 'badge-running';
            else if (j.status === 'done') statusClass = 'badge-success';
            else if (j.status === 'failed') statusClass = 'badge-failed';

            return `<li style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 4px;">
              <div style="display: flex; justify-content: space-between; align-items: top;">
                <span style="font-weight: 500; font-size: 0.75rem;">${esc(j.chapter_file)}</span>
                <span class="badge ${statusClass}" style="font-size: 0.6rem; padding: 2px 4px;">${j.status}</span>
              </div>
              ${j.error ? `<div class="text-error" style="font-size: 0.65rem; margin-top: 2px;">${esc(j.error)}</div>` : ''}
            </li>`;
          }).join('');
        }

        const backfillBtn = document.getElementById('backfillBtn');
        if (backfillBtn && backfillBtn.innerText !== "Resolving...") {
          backfillBtn.disabled = (wavs === 0);
        }

        // Poll for log updates separately (now handled by own interval)
        // updateLogView(); 
      } catch (e) {
        console.error("Refresh failed", e);
      }
    }

    // Event Listeners
    document.addEventListener('click', (e) => {
      // If clicking inside a card or the sidebar/controls, do nothing
      if (e.target.closest('.chapter-card') || e.target.closest('.sidebar') || e.target.closest('.btn')) return;

      // If clicking on the grid container or main background, deselect
      if (currentSelectedCard) {
        document.getElementById(`card-${currentSelectedCard}`)?.classList.remove('active');
        currentSelectedCard = null;
        updateLogView(); // Will reset to System Console
        document.getElementById('previewTitle').innerText = 'Chapter Preview';
        document.getElementById('previewArea').innerText = 'Select a chapter to see its preview.';
      }
    });

    document.getElementById('chapterGrid').addEventListener('click', async (e) => {
      const card = e.target.closest('.chapter-card');
      if (!card) return;

      if (currentSelectedCard) {
        document.getElementById(`card-${currentSelectedCard}`)?.classList.remove('active');
      }

      currentSelectedCard = card.dataset.filename;
      card.classList.add('active');

      // Update Log Tab
      const job = jobData[currentSelectedCard];
      const consoleEl = document.getElementById('logConsole');
      const logTitle = document.getElementById('logTitle');
      const logSubtitle = document.getElementById('logSubtitle');

      if (logSubtitle) logSubtitle.innerText = `Viewing: ${currentSelectedCard}`;

      if (job) {
        logTitle.innerText = `Logs: ${currentSelectedCard} (${job.engine})`;
        consoleEl.innerText = job.log || "No logs available yet.";
      } else {
        logTitle.innerText = `System Console`;
        consoleEl.innerText = `No job record for ${currentSelectedCard}.`;
      }
      consoleEl.scrollTop = consoleEl.scrollHeight;

      // Update Preview/Analysis Tab
      restorePreview();
    });

    function editTitle(event, filename) {
      event.stopPropagation();
      const textEl = document.getElementById(`title-text-${filename}`);
      const inputEl = document.getElementById(`title-input-${filename}`);
      if (textEl && inputEl) {
        textEl.style.display = 'none';
        inputEl.style.display = 'block';
        inputEl.focus();
        inputEl.select();
      }
    }

    function handleTitleKey(event, filename) {
      if (event.key === 'Enter') {
        event.target.blur();
      } else if (event.key === 'Escape') {
        const textEl = document.getElementById(`title-text-${filename}`);
        const inputEl = document.getElementById(`title-input-${filename}`);
        inputEl.value = textEl.innerText;
        event.target.blur();
      }
    }

    async function saveTitle(filename) {
      const textEl = document.getElementById(`title-text-${filename}`);
      const inputEl = document.getElementById(`title-input-${filename}`);
      const newTitle = inputEl.value.strip ? inputEl.value.strip() : inputEl.value.trim();

      textEl.style.display = 'block';
      inputEl.style.display = 'none';

      if (!newTitle || newTitle === textEl.innerText) return;

      try {
        const formData = new FormData();
        formData.append('chapter_file', filename);
        formData.append('new_title', newTitle);
        const resp = await fetch('/api/job/update_title', { method: 'POST', body: formData });
        if (resp.ok) {
          textEl.innerText = newTitle;
          textEl.classList.add('customized');
          if (jobData[filename]) jobData[filename].custom_title = newTitle;
        } else {
          const data = await resp.json();
          alert(data.error || "Failed to update title.");
          inputEl.value = textEl.innerText;
        }
      } catch (err) {
        console.error("Failed to save title", err);
        inputEl.value = textEl.innerText;
      }
    }

    document.getElementById('gridToggle').addEventListener('click', () => {
      document.getElementById('chapterGrid').classList.remove('list-view');
      document.getElementById('gridToggle').style.background = 'var(--accent)';
      document.getElementById('listToggle').style.background = 'transparent';
    });

    document.getElementById('listToggle').addEventListener('click', () => {
      document.getElementById('chapterGrid').classList.add('list-view');
      document.getElementById('listToggle').style.background = 'var(--accent)';
      document.getElementById('gridToggle').style.background = 'transparent';
    });

    document.getElementById('logTab').addEventListener('click', () => {
      document.getElementById('logTab').classList.add('active');
      document.getElementById('previewTab').classList.remove('active');
      document.getElementById('logContent').classList.add('active');
      document.getElementById('previewContent').classList.remove('active');
    });

    document.getElementById('previewTab').addEventListener('click', () => {
      document.getElementById('previewTab').classList.add('active');
      document.getElementById('logTab').classList.remove('active');
      document.getElementById('previewContent').classList.add('active');
      document.getElementById('logContent').classList.remove('active');
    });

    async function runAnalysis(e) {
      if (!currentSelectedCard) {
        alert("Please select a chapter first.");
        return;
      }
      const area = document.getElementById('previewArea');
      area.innerText = "Running analysis...";
      try {
        const formData = new FormData();
        formData.append('chapter_file', currentSelectedCard);
        formData.append('ajax', 'true');
        const resp = await fetch('/analyze_long', { method: 'POST', body: formData });
        const data = await resp.json();
        area.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem;">
            <span style="font-weight: 600; color: var(--accent);">Analysis Report</span>
            <button class="btn btn-outline" style="padding: 2px 8px; font-size: 0.7rem;" onclick="restorePreview()">Back to Preview</button>
          </div>
          <div class="report-view">${esc(data.report)}</div>
        `;
      } catch (err) {
        area.innerText = "Analysis failed.";
      }
    }

    function setPreviewMode(mode) {
      previewMode = mode;
      document.getElementById('modeRawBtn').classList.toggle('active', mode === 'raw');
      document.getElementById('modeEngineBtn').classList.toggle('active', mode === 'engine');
      restorePreview();
    }

    async function restorePreview() {
      if (!currentSelectedCard) return;
      document.getElementById('previewTitle').innerText = (previewMode === 'engine' ? `Engine: ` : `Preview: `) + currentSelectedCard;
      const area = document.getElementById('previewArea');
      area.innerText = "Loading preview...";
      try {
        const isProcessed = previewMode === 'engine';
        const resp = await fetch(`/api/preview/${encodeURIComponent(currentSelectedCard)}?processed=${isProcessed}`);
        const data = await resp.json();

        if (data.error) {
          area.innerText = data.error;
          return;
        }

        if (isProcessed) {
          const lines = data.text.split('\n').filter(l => l.trim().length > 0);
          if (lines.length === 0) {
            area.innerText = "[Empty Output - Possible context packing issue]";
          } else {
            area.innerHTML = lines.map((line, i) =>
              `<div class="engine-chunk" data-label="Chunk ${i + 1} (${line.length} chars)">${esc(line)}</div>`
            ).join('');
          }
        } else {
          area.innerText = data.text || "No preview available.";
        }
      } catch (err) {
        area.innerText = "Failed to load preview.";
      }
    }

    async function runBackfill(btn) {
      const originalText = btn.innerText;
      btn.innerText = "Resolving...";
      btn.disabled = true;
      try {
        const resp = await fetch('/queue/backfill_mp3', { method: 'POST' });
        const data = await resp.json();
        alert(`Resolved ${data.converted} files. ${data.failed} failures.`);
        refreshJobList();
      } catch (err) {
        alert("Failed to run backfill.");
      } finally {
        btn.innerText = originalText;
        btn.disabled = false;
      }
    }

    async function handleClear() {
      if (!confirm('Clear all job history and reset the queue?')) return;

      // Immediate UI reset
      jobData = {};
      currentSelectedCard = null;

      // Clear status badges and progress bars
      document.querySelectorAll('.status-badge-container').forEach(el => el.innerHTML = '');
      document.querySelectorAll('.progress-container').forEach(el => el.style.display = 'none');
      document.querySelectorAll('.chapter-card').forEach(el => {
        el.classList.remove('active');
        const footer = el.querySelector('.card-footer');
        if (footer && (footer.querySelector('.badge-failed') || footer.querySelector('p'))) {
          footer.innerHTML = '<p class="text-muted" style="font-size: 0.8rem;">Ready.</p>';
        }
      });

      // Reset bottom panel
      document.getElementById('logConsole').innerText = 'Queue cleared.';
      document.getElementById('logTitle').innerText = 'System Console';
      document.getElementById('previewTitle').innerText = 'Chapter Preview';
      document.getElementById('previewArea').innerText = 'Select a chapter to see its preview.';
      document.getElementById('globalStatus').innerText = '0 Running ‚Ä¢ 0 Queued';

      try {
        await fetch('/queue/clear', { method: 'POST' });
        setTimeout(refreshJobList, 100);
      } catch (err) {
        console.error("Failed to clear backend", err);
      }
    }

    // Rename main loop to refreshJobList
    async function refreshJobList() {
      return refreshJobs();
    }

    // --- WebSocket Implementation ---
    let socket = null;
    let wsReconnectTimer = null;

    function connectWS() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;

      console.log("Connecting to WebSocket...");
      socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log("WebSocket connected.");
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
        // Sync everything on connect
        refreshJobList();
      };

      socket.onmessage = async (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'job_updated') {
            const jid = data.job_id;
            const updates = data.updates;

            // Find filename for this job ID if we don't have it
            // Typically our jobs are indexed by filename in jobData
            let filename = null;
            for (const f in jobData) {
              if (jobData[f].id === jid) {
                filename = f;
                break;
              }
            }

            // If it's a new job or we don't know the filename yet, refresh the whole list
            // Or if it's an important status change ('done', 'failed', 'running')
            if (!filename || updates.status || updates.error) {
              refreshJobList();
            } else {
              // incremental update for progress/logs/warnings
              Object.assign(jobData[filename], updates);
              updateCardStatus(filename, jobData[filename]);

              // If we are viewing this specific job's logs, update log view
              if (currentSelectedCard === filename || (updates.status === 'running' && !currentSelectedCard)) {
                updateLogView();
              }
            }
          }
        } catch (e) {
          console.error("WS Message Error:", e);
        }
      };

      socket.onclose = () => {
        console.warn("WebSocket disconnected. Retrying in 5s...");
        socket = null;
        if (!wsReconnectTimer) {
          wsReconnectTimer = setTimeout(connectWS, 5000);
        }
      };

      socket.onerror = (err) => {
        console.error("WebSocket error:", err);
      };
    }

    connectWS();

    refreshJobList();
    // Heavy list update: fallback every 30s (was 5s)
    setInterval(refreshJobList, 30000);

    // Fast log update: fallback every 5s (was 1s)
    updateLogView();
    setInterval(updateLogView, 5000);

    async function openAssemblyModal() {
      const title = document.getElementById('exportTitleInput').value.trim();
      if (!title) {
        alert("Please enter a book title.");
        return;
      }

      document.getElementById('modalFieldTitle').value = title;

      const modal = document.getElementById('assemblyModal');
      const list = document.getElementById('chapterPreviewList');
      const durationText = document.getElementById('totalDurationText');

      list.innerHTML = '<tr><td colspan="3" style="text-align: center;">Calculating durations...</td></tr>';
      modal.classList.add('active');

      try {
        const resp = await fetch('/api/audiobook/prepare');
        const data = await resp.json();

        if (!data.chapters || data.chapters.length === 0) {
          list.innerHTML = '<tr><td colspan="3" style="text-align: center;">No audio files found.</td></tr>';
          return;
        }

        list.innerHTML = data.chapters.map((c, idx) => {
          const m = Math.floor(c.duration / 60);
          const s = Math.floor(c.duration % 60);
          const startM = Math.floor(c.start_sec / 60);
          const startS = Math.floor(c.start_sec % 60);

          return `<tr class="assembly-row" data-filename="${esc(c.filename)}">
            <td style="text-align: center;">
              <input type="checkbox" checked class="chapter-include-check">
            </td>
            <td>
              <input type="text" class="chapter-title-input" value="${esc(c.title)}" style="width: 100%; background: rgba(255,255,255,0.05); border: 1px solid var(--border); border-radius: 4px; color: #fff; padding: 2px 6px;">
            </td>
            <td class="text-muted" style="font-size: 0.75rem;">${startM}m ${startS}s</td>
            <td class="text-muted" style="font-size: 0.75rem;">${m}m ${s}s</td>
          </tr>`;
        }).join('');

        const totalM = Math.floor(data.total_duration / 60);
        const totalS = Math.floor(data.total_duration % 60);
        durationText.innerText = `Total Duration: ${totalM}m ${totalS}s`;

      } catch (err) {
        console.error("Prep failed", err);
        list.innerHTML = '<tr><td colspan="3" style="text-align: center; color: var(--error);">Error loading preview.</td></tr>';
      }
    }

    function closeAssemblyModal() {
      document.getElementById('assemblyModal').classList.remove('active');
    }

    async function confirmAssembly() {
      const btn = document.getElementById('confirmAssemblyBtn');
      const title = document.getElementById('modalFieldTitle').value.trim();
      const author = document.getElementById('modalFieldAuthor').value.trim();
      const narrator = document.getElementById('modalFieldNarrator').value.trim();

      if (!title) {
        alert("Title is required.");
        return;
      }

      const chapterData = [];
      document.querySelectorAll('.assembly-row').forEach(row => {
        const include = row.querySelector('.chapter-include-check').checked;
        if (include) {
          chapterData.push({
            filename: row.dataset.filename,
            title: row.querySelector('.chapter-title-input').value.trim()
          });
        }
      });

      if (chapterData.length === 0) {
        alert("Please select at least one chapter.");
        return;
      }

      const originalText = btn.innerText;
      btn.innerText = "Queueing...";
      btn.disabled = true;

      try {
        const formData = new FormData();
        formData.append('title', title);
        formData.append('author', author);
        formData.append('narrator', narrator);
        formData.append('chapters', JSON.stringify(chapterData));

        const resp = await fetch('/create_audiobook', { method: 'POST', body: formData });
        if (resp.ok) {
          closeAssemblyModal();
          refreshJobList();
          // Clear input
          document.getElementById('exportTitleInput').value = '';
        } else {
          alert("Failed to enqueue assembly job.");
        }
      } catch (err) {
        console.error("Assembly enqueue failed", err);
        alert("Error starting assembly.");
      } finally {
        btn.innerText = originalText;
        btn.disabled = false;
      }
    }

    // Handle selected chapter on load
    window.addEventListener('scroll', () => { }, { passive: true }); // dummy to allow scroll check
    const initialChapter = "{{ selected_chapter }}";
    if (initialChapter) {
      setTimeout(() => {
        selectCardAndScroll(initialChapter);
      }, 500);
    }
  </script>
</body>

</html>